// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

model Group {
  id           String        @id
  name         String
  information  String?       @db.Text
  currency     String        @default("$")
  currencyCode String?
  participants Participant[]
  expenses     Expense[]
  activities   Activity[]
  createdAt    DateTime      @default(now())
  deletedAt    DateTime?
  // Password protection (Issue #2)
  passwordSalt String?       // Salt for PBKDF2 key derivation (base64 encoded)
  passwordHint String?       // Encrypted password hint

  // Indexes for performance
  @@index([createdAt])  // For auto-delete inactive groups query
  @@index([deletedAt])  // For grace period cleanup query
}

model Participant {
  id              String           @id
  name            String
  group           Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId         String
  expensesPaidBy  Expense[]
  expensesPaidFor ExpensePaidFor[]
}

model Category {
  id       Int       @id @default(autoincrement())
  grouping String
  name     String
  // Note: Expense relation removed for E2EE (Issue #19)
  // categoryId is now encrypted, so FK relation is not possible
}

model Expense {
  id               String            @id
  group            Group             @relation(fields: [groupId], references: [id], onDelete: Cascade)
  expenseDate      DateTime          @default(dbgenerated("CURRENT_DATE")) @db.Date
  title            String
  // Category is now stored as encrypted string for E2EE (Issue #19)
  // Legacy data may still have integer values as strings (e.g., "0", "1")
  categoryId       String            @default("0") // Encrypted category ID
  amount           String            // Encrypted amount (cents as string or encrypted)
  originalAmount   String?           // Encrypted original amount
  originalCurrency String?
  conversionRate   Decimal?
  paidBy           Participant       @relation(fields: [paidById], references: [id], onDelete: Cascade)
  paidById         String
  paidFor          ExpensePaidFor[]
  groupId          String
  isReimbursement  Boolean           @default(false)
  splitMode        SplitMode         @default(EVENLY)
  createdAt        DateTime          @default(now())
  documents        ExpenseDocument[]
  notes            String?

  recurrenceRule         RecurrenceRule?       @default(NONE)
  recurringExpenseLink   RecurringExpenseLink?
  recurringExpenseLinkId String?

  // Indexes for performance
  @@index([groupId, expenseDate(sort: Desc)])  // For expense listing by date
  @@index([groupId, createdAt(sort: Desc)])    // For recent expenses query
  @@index([paidById])                          // For participant-specific queries
}

model ExpenseDocument {
  id        String   @id
  url       String
  width     Int
  height    Int
  Expense   Expense? @relation(fields: [expenseId], references: [id])
  expenseId String?
}

enum SplitMode {
  EVENLY
  BY_SHARES
  BY_PERCENTAGE
  BY_AMOUNT
}

model RecurringExpenseLink {
  id                    String  @id
  groupId               String
  currentFrameExpense   Expense @relation(fields: [currentFrameExpenseId], references: [id], onDelete: Cascade)
  currentFrameExpenseId String  @unique

  // Note: We do not want to link to the next expense because once it is created, it should be 
  // treated as it's own independent entity. This means that if a user wants to delete an Expense
  // and any prior related recurring expenses, they'll need to delete them one by one.
  nextExpenseCreatedAt DateTime?
  nextExpenseDate      DateTime

  @@index([groupId])
  @@index([groupId, nextExpenseCreatedAt, nextExpenseDate(sort: Desc)])
}

enum RecurrenceRule {
  NONE
  DAILY
  WEEKLY
  MONTHLY
}

model ExpensePaidFor {
  expense       Expense     @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  expenseId     String
  participantId String
  shares        String      @default("1") // Encrypted shares (or plain number as string)

  @@id([expenseId, participantId])
  @@index([participantId])  // For participant-centric balance queries
}

model Activity {
  id            String       @id
  group         Group        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId       String
  time          DateTime     @default(now())
  activityType  ActivityType
  participantId String?
  expenseId     String?
  data          String?

  @@index([groupId, time(sort: Desc)])  // For activity feed queries
}

enum ActivityType {
  UPDATE_GROUP
  CREATE_EXPENSE
  UPDATE_EXPENSE
  DELETE_EXPENSE
}

// Private Instance Mode (Issue #4)
model Admin {
  id                 String   @id @default(cuid())
  email              String   @unique
  password           String   // bcrypt hashed
  name               String?
  mustChangePassword Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model WhitelistUser {
  id                 String   @id @default(cuid())
  email              String   @unique
  password           String?  // bcrypt hashed (null until first login setup)
  name               String?
  mustChangePassword Boolean  @default(true) // Must change on first login
  addedById          String   // Admin who added this user
  createdAt          DateTime @default(now())
}
